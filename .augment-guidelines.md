# Augment Guidelines for Digigoods API

## Project Context

Digigoods is a **Spring Boot 3.5.4 backend API** for a digital marketplace that enables purchasing digital goods with discount functionality. The core business flow involves JWT-based authentication, product browsing, discount application, and order processing with stock management.

**Key Features:**
- JWT-based user authentication
- Product catalog management with stock tracking
- Flexible discount system (general and product-specific)
- Order processing with complex discount rules
- RESTful API design with comprehensive error handling

## Technology Stack

- **Framework**: Spring Boot 3.5.4 with Java 21
- **Database**: PostgreSQL 15+ (production), H2 (testing)
- **ORM**: Spring Data JPA with Hibernate
- **Migration**: Liquibase for database versioning
- **Security**: Spring Security with JWT (io.jsonwebtoken)
- **Build**: Maven 3.x with Maven Wrapper
- **Testing**: JUnit 5, Mockito, Spring Boot Test
- **Containerization**: Docker & Docker Compose
- **Code Quality**: Checkstyle (Google Java Style), JaCoCo coverage

## Development Standards

### Code Style & Formatting
- Follow **Google Java Style Guide** enforced by Checkstyle
- Use **2-space indentation** for all files (Java, XML, YAML, properties)
- Refer to `.editorconfig` for formatting rules
- Run `./mvnw checkstyle:check` before committing code
- Use **Lombok** to reduce boilerplate code, especially for DTOs and entities

### Architectural Patterns
- **Layered Architecture**: Controller → Service → Repository → Entity
- **Dependency Injection**: Use constructor injection (not field injection)
- **DTO Pattern**: Separate DTOs for request/response from entities
- **Exception Handling**: Custom exceptions with global exception handler
- **Validation**: Use Bean Validation annotations (@Valid, @NotNull, etc.)

### Naming Conventions
- **Classes**: PascalCase (e.g., `ProductService`, `CheckoutController`)
- **Methods**: camelCase with descriptive names
- **Constants**: UPPER_SNAKE_CASE
- **Database**: snake_case for table/column names
- **REST Endpoints**: kebab-case if needed, prefer nouns

## Security Guidelines

### JWT Implementation
- **Token Structure**: Include userId and username in claims
- **Expiration**: 24 hours (86400000ms) for tokens
- **Secret Key**: Minimum 256 bits for HS256 algorithm
- **Authorization Header**: `Authorization: Bearer <token>`

### Security Configuration
- **Public Endpoints**: `/auth/**`, `/actuator/**`, `/products`, `/discounts`
- **Protected Endpoints**: `/orders` and any user-specific operations
- **Stateless Sessions**: No server-side session storage
- **Password Encoding**: Use BCrypt with Spring Security's PasswordEncoder

### Security Best Practices
- Validate user authorization in service layer (not just authentication)
- Never expose sensitive data in API responses
- Use HTTPS in production environments
- Implement proper CORS configuration if needed

## Database Guidelines

### JPA/Hibernate Patterns
- **Entity Annotations**: Use `@Entity`, `@Table`, `@Column` explicitly
- **ID Generation**: `@GeneratedValue(strategy = GenerationType.IDENTITY)`
- **Relationships**: Use `@ManyToOne`, `@ManyToMany` with proper fetch strategies
- **Timestamps**: Use `@PrePersist` for automatic timestamp generation
- **Precision**: Use `precision` and `scale` for BigDecimal fields

### Liquibase Migration Standards
- **File Naming**: `001-create-[table-name]-table.yaml`
- **Incremental Changes**: Never modify existing changesets
- **Master File**: Update `db.changelog-master.yaml` for new migrations
- **Data Seeding**: Separate changeset for sample data (006-insert-sample-data.yaml)

### Data Modeling Best Practices
- Use **BigDecimal** for monetary values with appropriate precision
- Implement **soft deletes** where business logic requires data retention
- Use **enums** for fixed value sets (e.g., DiscountType)
- Create **junction tables** for many-to-many relationships

## Testing Guidelines

### Test Structure & Naming
- **Framework**: JUnit 5 with Mockito for mocking
- **Test Method Naming**: `givenCondition_whenAction_thenExpectedResult`
- **Display Names**: Use `@DisplayName` with descriptive test descriptions
- **Test Organization**: Use `@Nested` classes for grouping related tests

### Test Patterns (AAA Pattern)
```java
@Test
@DisplayName("Given valid product IDs, when getting products, then return products")
void givenValidProductIds_whenGettingProducts_thenReturnProducts() {
    // Arrange
    List<Long> productIds = List.of(1L, 2L);
    
    // Act
    List<Product> result = productService.getProductsByIds(productIds);
    
    // Assert
    assertEquals(2, result.size());
}
```

### Unit Testing Standards
- **Mocking**: Use `@ExtendWith(MockitoExtension.class)` and `@Mock`
- **Test Data**: Create test data in `@BeforeEach` methods
- **Assertions**: Use JUnit 5 assertions, prefer specific assertions
- **Coverage**: Aim for high coverage but focus on business logic

### Integration Testing Standards
- **Annotations**: `@SpringBootTest`, `@AutoConfigureWebMvc`, `@ActiveProfiles("test")`
- **Database**: Use H2 in-memory database for tests
- **MockMvc**: Use MockMvc for controller integration tests
- **Test Isolation**: Use `@Transactional` for automatic rollback
- **Test Data**: Clean and set up data in `@BeforeEach`

## Build and Deployment

### Maven Commands
```bash
# Build and compile
./mvnw clean compile

# Run tests with coverage
./mvnw clean test jacoco:report

# Run application locally
./mvnw spring-boot:run

# Check code style
./mvnw checkstyle:check

# Package application
./mvnw clean package
```

### Docker Usage
```bash
# Start with Docker Compose (recommended)
docker-compose up --build

# Stop and clean up
docker-compose down -v
```

### Environment Configuration
- **Development**: Use `application.properties` with local PostgreSQL
- **Testing**: Use `application-test.properties` with H2 database
- **Production**: Override via environment variables or Docker Compose

## Code Quality Standards

### Coverage Expectations
- **Minimum Coverage**: Aim for 80%+ line coverage
- **Focus Areas**: Service layer business logic, exception handling
- **Coverage Reports**: Available at `target/site/jacoco/index.html`
- **Verification**: Run coverage before committing changes

### Documentation Standards
- **Javadoc**: Document all public methods and classes
- **README**: Keep README.md updated with setup instructions
- **API Documentation**: Consider adding OpenAPI/Swagger documentation
- **Code Comments**: Explain complex business logic, not obvious code

## Common Patterns

### Controller Pattern
```java
@RestController
@RequestMapping("/api-path")
public class ExampleController {
    
    private final ExampleService exampleService;
    
    public ExampleController(ExampleService exampleService) {
        this.exampleService = exampleService;
    }
    
    @GetMapping
    public ResponseEntity<List<Example>> getAll() {
        List<Example> examples = exampleService.getAll();
        return ResponseEntity.ok(examples);
    }
}
```

### Service Pattern
```java
@Service
@Transactional
public class ExampleService {
    
    private final ExampleRepository exampleRepository;
    
    public ExampleService(ExampleRepository exampleRepository) {
        this.exampleRepository = exampleRepository;
    }
    
    public List<Example> getAll() {
        return exampleRepository.findAll();
    }
}
```

### Exception Handling Pattern
- Create custom exceptions extending `RuntimeException`
- Use `@ControllerAdvice` for global exception handling
- Return appropriate HTTP status codes with error messages
- Include request context in error responses

## Troubleshooting

### Common Issues & Solutions

**Database Connection Issues:**
- Verify PostgreSQL is running on port 5432
- Check credentials in `application.properties`
- Use Docker Compose for consistent environment

**Test Failures:**
- Ensure H2 database is properly configured in test profile
- Check for test data conflicts between tests
- Verify mock configurations in unit tests

**JWT Token Issues:**
- Verify secret key length (minimum 256 bits)
- Check token expiration settings
- Ensure proper Authorization header format

**Build Issues:**
- Run `./mvnw clean` to clear build artifacts
- Check Checkstyle violations with `./mvnw checkstyle:check`
- Verify Java 21 compatibility

**Coverage Issues:**
- Run `./mvnw clean test jacoco:report` for fresh coverage
- Focus on testing service layer business logic
- Use integration tests for complex workflows

### Performance Considerations
- Use appropriate JPA fetch strategies to avoid N+1 queries
- Implement pagination for large result sets
- Consider caching for frequently accessed data
- Monitor database query performance in development

---

**Note**: Always run tests before committing code and ensure coverage reports meet project standards. When in doubt, refer to existing code patterns in the project for consistency.
